# Open WebUI Extension Cheatcode (for agents)

- types: `Tools` (model-callable methods), `Filter` (inlet/outlet), `Pipe`/pipeline (message-level), `Action` (UI button)
- valves: define an inner `Valves(BaseModel)` with `Field(..., description=...)`; settings are editable in Admin and exposed as `self.valves` at runtime
- reserved args (auto-injected, avoid shadowing): `__body__`, `__user__`, `__metadata__`, `__request__`, `__connection__`, `__response__`, `__llm__`, `__task__`, `__event_emitter__`, `__run__`, `__logger__`, `__webhook__`, `__plugin__`, plus `body` for payloads
- filters: implement `inlet(self, body: dict, ...) -> dict` before LLM and/or `outlet(self, body: dict, ...) -> dict` after; must return the (mutated) `body` dict; great for light prompt/output shaping
- pipe/pipeline: `def pipe(self, body: dict, __event_emitter__=None, __user__=None, __metadata__=None, __request__=None, __response__=None) -> dict`; operate on full message payload; use `__event_emitter__` to stream chunks via `send_event("data", chunk)` then finalize with `send_event("response", body)`
- action: `async def action(self, body: dict, __user__=None, __event_emitter__=None, __event_call__=None, __request__=None, __model__=None, __id__=None)`; appears as toolbar button; may prompt via `__event_call__` and push updates via `__event_emitter__`
- events: any plugin can emit realtime UI events with `await __event_emitter__({"type": "...", "data": {...}})`; interactive flows use `await __event_call__(...)` for dialogs/inputs; routing metadata is auto-filled
- tools: class `Tools` methods (typed parameters) become callable tools; assign to models that support function calling; valves hold per-tool config such as API keys
- DB anchors: SQLite lives at `/app/backend/data/webui.db` (container) or host-mounted volume. `function` table holds filters/actions (columns: id, user_id, name, type, content, meta, valves, is_active, is_global, created_at, updated_at). `tool` table holds workspace tools (id, user_id, name, content, specs, meta, valves, access_control, created_at, updated_at). AirPods importer currently writes the `function` rows; workspace tools must be imported via UI/JSON and land in `tool`.
- Auto-import contract (AirPods): repo `plugins/open-webui/**/*.py` is mirrored into the WebUI volume (stale files pruned), then any module exposing a `Filter`/`Pipeline`/`action` hook becomes a `function` row. IDs use the filename stem, names are title-cased, `type` is auto-detected (`action` if `def action`, `pipeline` if `class Pipeline`/`def pipe`, otherwise `filter`). Files that only ship a `Tools` class are copied but skipped so they can be managed via Open WebUI’s Tools UI without creating dead entries. `meta.description` notes source+type, `is_active`=1, `is_global`=0, owner=`system`; upserts keep ids stable. No `tool` table writes yet. (Source: `airpods/plugins.py`.)
- valves in DB: `valves` column stores JSON for user-configurable settings defined by each plugin’s `Valves` model. AirPods importer leaves it empty/null so defaults come from code; after enabling/editing in Admin, Open WebUI writes user values back into `valves` and reloads them into `self.valves` on each invocation.
